# -*- coding: utf-8 -*-
"""ner_predictor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17IjeGjL5nhOKSn_L3_CPjvIs0CDQ-g5r
"""

# !pip install overrides
# !pip install allennlp
# !python -m spacy download en
# !pip install https://s3-us-west-2.amazonaws.com/ai2-s2-scispacy/releases/v0.2.4/en_core_sci_sm-0.2.4.tar.gz

import sys
sys.path.append('../')

import pickle
import sys
import re
# import nltk
import os
from tqdm import tqdm
import numpy as np
import json
import torch
from typing import List, Union, Tuple
import tarfile
import argparse
import itertools
from sklearn import metrics
import en_core_sci_sm

# from config import Span
from common import Instance, Sentence

# !rm -rf dataset/*

# filter_material = True
# filter_maethodparam = True

# def find_name(values, key):
#     start_ind = values[key].split().index(key.split()[0])

#     tags = nltk.pos_tag(values[key].split())

#     for i in range(start_ind-1, 0, -1):
#         if tags[i][1].startswith('NN') or tags[i][1] in ['.',',']:
#             value = tags[i][0]
#             i-=1
#             while i>=0 and (tags[i][1] in ['CC'] or tags[i][1].startswith('NN') or tags[i][1] in ['.',',']):
#                 value += ' ' + tags[i][0]
#                 i-=1
#             return (value)
#             # print(tags)
#             break
#     return ''

class Span:
    """
    A class of `Span` where we use it during evaluation.
    We construct spans for the convenience of evaluation.
    """
    def __init__(self, left: int, right: int, type: str, line : str):
        """
        A span compose of left, right (inclusive) and its entity label.
        :param left:
        :param right: inclusive.
        :param type:
        """
        self.left = left
        self.right = right
        self.type = type
        self.line = line

    def __eq__(self, other):
        return self.left == other.left and self.right == other.right and self.type == other.type

    def __hash__(self):
        return hash((self.left, self.right, self.type))


def find_values(inst, key, highlight):
    # output = []
    # words = inst.input.words
    # highlight_list = highlight.split()
    # prediction = inst.prediction

    # indices = [ i for i in range(len(prediction)) if prediction[i] == 'B-'+key ]

    # for index in indices:
    #     if words[index:index+len(highlight_list)] == highlight_list:
    #         right,left = index,index
    #         while right<len(words) and words[right]!='<UNK>':
    #             right += 1
    #         while left>=0 and words[left]!='<UNK>':
    #             left -= 1

    #         output.append(' '.join(words[left+1:right]))

    # output = list(set(output))
    # return output
    return ' '.join(inst.input.words)


def is_subsequence(needle, haystack):

    # print(needle)
    for i in range(len(haystack) - len(needle) + 1):
        # print(haystack[i:i+len(needle)])
        if haystack[i:i+len(needle)] == needle:
            # print('MATCH')
            return i+len(needle)

    return -1

def filter_material_title(materials_, mat_section, freq):
    found = False
    temp = []
    keys = list(freq.keys())

    for each in keys:
        for each_mat in materials_:
            if each_mat in each and "TITLE" in mat_section[each_mat]:
                found = True
                temp.append(each_mat)
                break

    if len(temp)>0:
        keys = temp

    return keys, found

def filter_material_frequency(top, freq):
    if len(top) >= 2:
        top = list(freq.keys())[:2]

    return top

def filter_materials(dict_, insts, mat_section):
    if 'MATERIAL' in dict_:

        materials_ = list(dict_['MATERIAL'].keys())

        materials = []
        for i, mat1 in enumerate(materials_):
            found = False
            for mat2 in materials_:
                if mat2 == mat1:
                    continue
                if mat1 in mat2:
                    found = True
                    break

            if not found:
                materials.append(mat1)

        freq = {}
        for mat in materials:
            freq[mat] = 0

        # print(materials)

        for inst in insts:
            words = inst.input.words
            i = 0

            for each in materials:
                each_split = each.split()
                # print(words)
                # print(each_split)
                ind = is_subsequence(each_split, words)
                if ind != -1:
                    freq[each] += 1
                    words = words[ind:]

        freq = {k: v for k, v in sorted(freq.items(), reverse=True, key=lambda item: item[1])}


        filtered_keys, found = filter_material_title(materials_, mat_section, freq)
        if not found:
            filtered_keys = filter_material_frequency(filtered_keys, freq)

        print(filtered_keys)

        # delete_unwanted_keys
        for key in materials_:
            if key not in filtered_keys:
                del dict_['MATERIAL'][key]

    return dict_

def filter_structures(dict_, structure_section, valid_sections, values_s, outputs_s):
    if 'STRUCTURE' in dict_:

        # keys = list(dict_['STRUCTURE'].keys())[:]
        # for each in keys:
        #     # if structure_section[each] != 'TITLE' and structure_section[each] not in valid_sections:
        #     # print(structure_section[each])
        #     if structure_section[each] not in valid_sections and structure_section[each] in ['0']:
        #         del dict_['STRUCTURE'][each]

        # structure_ = list(dict_['STRUCTURE'].keys())

        # structure = []
        # for i, structure1 in enumerate(structure_):
        #     found = False
        #     for structure2 in structure_:
        #         if structure2 == structure1:
        #             continue
        #         if structure1 in structure2:
        #             found = True
        #             break

        #     if not found:
        #         structure.append(structure1)

        # for key in structure_:
        #     if key not in structure:
        #         del dict_['STRUCTURE'][key]

        materials_ = list(dict_['MATERIAL'].keys()) if 'MATERIAL' in dict_ else []

        structure_ = list(dict_['STRUCTURE'].keys())
        structure_count = {}

        for key in structure_:
            # sentences = values_s[key].split('<UNK>')
            sections = values_s[key]

            structure_count[key] = 0

            for section in sections:
                structure_count[key] += section.count(key)


            not_to_be_deleted = False

            for section_id, section in enumerate(sections):

                sentences = section.split('<UNK>')
                cnt = 0

                prev_sentence = None
                prev_output = None

                next_sentence = None
                next_output = None

                found = False

                structure_sentence = None
                structure_output = None

                for sentence in sentences:
                    # sentence = str(sentence.string)
                    if found:
                        next_sentence = sentence
                        next_output = outputs_s[key][section_id][cnt: cnt + len(sentence.split())]
                        break

                    if key in sentence:
                        structure_sentence = sentence
                        structure_output = outputs_s[key][section_id][cnt: cnt + len(sentence.split())]
                        cnt += len(sentence.split())
                        found = True
                        continue
                    prev_sentence = sentence
                    prev_output = outputs_s[key][section_id][cnt: cnt + len(sentence.split())]
                    cnt += len(sentence.split()) + 1

                # if structure_output.count('B-STRUCTURE') >= 1:
                #     print(structure_sentence)

                if (prev_output is not None and prev_output.count('B-MATERIAL') >= 1) or (structure_output is not None and structure_output.count('B-MATERIAL') >=1) or (next_sentence is not None and next_sentence.count('B-MATERIAL') >= 1):
                    not_to_be_deleted = True
                    break

            if not_to_be_deleted is False and structure_count[key]>3:
                del dict_['STRUCTURE'][key]

                # for material in materials_:
                #     print(material)
                #     if (prev_sentence is not None and material in prev_sentence) or (structure_sentence is not None and material in structure_sentence) or (next_sentence is not None and material in next_sentence):

                #         if structure_count[key]<=2:
                #             #This structure is valid
                #             not_to_be_deleted = True
                        
                #         break

                # if not_to_be_deleted is True:
                #     break
                
            # if not_to_be_deleted is False:
            #     del dict_['STRUCTURE'][key]


            if key=="cubic" or key=="periodic":
                try:
                    del dict_['STRUCTURE'][key]
                except:
                    print("deleted")
    return dict_


def temporary_fix_for_method(dict_):

    if "METHOD" in dict_:
        methods = []
        for each in dict_['METHOD']:
            if 'GGA' in each or 'PBE' in each or 'Perdew - Burke - Ernzerhof' in each or 'generalized gradient approximation' in each:
                methods.append('GGA / PBE')
            elif 'PAW' in each or 'projector augmented wave' in each or 'projector augmented plane - wave' in each:
                methods.append('PAW')
            else:
                methods.append(each)

        methods = list(set(methods))
        dict_['METHOD'] = {}
        for each in methods:
            dict_['METHOD'][each] = None
    return dict_


def create_dict_true(insts, valid_sections, filter_maethodparam, filter_material):
    dict_ = {}
    label_section = {}

    line = 0

    for inst in insts:
        words = inst.input.words
        true_labels = inst.output
        num_of_words = len(inst.input)

        chars_till_now = 0
        i = 0
        while i < num_of_words: 
            if true_labels[i][0] == 'B':
                
                start = chars_till_now

                label = true_labels[i].replace('S-','B-').replace('E-','I-')[2:]
                highlighted = words[i] + ' '
                start += len(words[i])
                i+=1

                
                while(i<num_of_words and true_labels[i][0]=='I'):
                    highlighted += words[i] + ' '
                    start += len(words[i])
                    i+=1

                # if label in ['CODE', 'STRUCTURE', 'MATERIAL', 'METHOD'] or (label == 'PARAMETER' and inst.input.heading in valid_sections):
                if True:

                    if label not in dict_:
                        dict_[label] = {}

                    if highlighted.strip() not in dict_[label]:
                        dict_[label][highlighted.strip()] = []
                        
                    dict_[label][highlighted.strip()].append(Span(chars_till_now, start -1, label, line))
                    label_section[highlighted.strip()] = inst.input.heading

                    chars_till_now = start
                    continue

            chars_till_now += len(words[i])
            i+=1

        line += 1
        # print(''.join(words))

    #temporary fix
    # temporary_fix_for_method(dict_)

    return dict_, label_section


def create_dict_pred(insts, valid_sections, filter_maethodparam, filter_material, filter_structure):

    dict_ = {}
    mat_section = {}
    structure_section = {}
    label_section = {}
    values_p = {}
    values_s = {}
    outputs_s = {}

    line = 0

    for inst in insts:
        words = inst.input.words
        prediction = inst.prediction

        num_of_words = len(inst.input)
        chars_till_now = 0
        i = 0
        while i < num_of_words: 
            if prediction[i][0] == 'B':
                
                start = chars_till_now

                label = prediction[i].replace('S-','B-').replace('E-','I-')[2:]
                highlighted = words[i] + ' '
                start += len(words[i])
                i+=1

                while(i<num_of_words and prediction[i][0]=='I'):
                    highlighted += words[i] + ' '
                    start += len(words[i])
                    i+=1

                highlighted = highlighted.replace('<UNK>', '')

                if label in ['CODE', 'STRUCTURE'] or (label in ['METHOD','PARAMETER'] and ( filter_maethodparam is False or inst.input.heading in valid_sections)) or (label in ['MATERIAL'] and (filter_material is False or inst.input.heading in ['TITLE', 'ABSTRACT'] or int(inst.input.heading) <= 0)):

                    if label not in dict_:
                        dict_[label] = {}

                    if highlighted.strip() not in dict_[label]:
                        dict_[label][highlighted.strip()] = []
                        
                    dict_[label][highlighted.strip()].append(Span(chars_till_now, start -1, label, line))

                    if label == 'MATERIAL' and highlighted.strip() not in mat_section:
                        mat_section[highlighted.strip()] = inst.input.heading

                    if label == 'STRUCTURE' and highlighted.strip() not in structure_section:
                        structure_section[highlighted.strip()] = inst.input.heading

                        if highlighted.strip() not in values_s:
                            values_s[highlighted.strip()] = []
                            outputs_s[highlighted.strip()] = []

                        values_s[highlighted.strip()].append(find_values(inst, 'STRUCTURE', highlighted.strip()))
                        outputs_s[highlighted.strip()].append(prediction)

                    if label == 'PARAMETER':
                        if highlighted.strip() not in values_p:
                            values_p[highlighted.strip()] = []
                        values_p[highlighted.strip()].append(find_values(inst, 'PARAMETER', highlighted.strip()))
                        # print(highlighted.strip())
                    label_section[highlighted.strip()] = inst.input.heading

                chars_till_now = start
                continue

            chars_till_now += len(words[i])
            i+=1

        line += 1
        # print(''.join(words))

    if filter_structure:
        dict_ = filter_structures(dict_, structure_section, valid_sections, values_s, outputs_s)

    if filter_material:
        dict_ = filter_materials(dict_, insts, mat_section)

    #temporary fix
    # temporary_fix_for_method(dict_)
    
    return dict_, label_section, values_p, values_s, outputs_s

def alternate_labels(original):
    matchh = re.compile('(.*?)([\w\d]+) \((.*)$')
    res = matchh.search(original)

    result = []

    if res is None:
        return result

    options = [x.strip() for x in res.group(3).split(';')]
    dict_ = {}
    for opt in options:
        if "=" not in opt:
            continue
        left = opt.split('=')[0].strip()
        right = opt.split('=')[1].split(',')
        dict_[left] = [x.replace('and', '').strip() for x in right]

    val = res.group(2)

    values = list(dict_.values())
    possibilites = []
    for element in itertools.product(*values):
        possibilites.append(element)

    for each in possibilites:
        alt = val
        for i, ch in enumerate(dict_):
            alt = alt.replace(ch, each[i])
        result.append(res.group(1) + alt)

    # print(result)
    # for ch in dict_:
    #     for each in dict_[ch]:
    #         alt = val.replace(ch, each)
    #         result.append(res.group(1) + alt)

    return result

def evaluate(predictions, true_labels):

    dict_overlap = {}
    matched_pred_dict = {}
    matched_true_dict = {}

    # print(true_labels)
    # print(predictions)
    for true_label in true_labels:
        if true_label not in dict_overlap:
            dict_overlap[true_label] = [0,0,0,0]
        dict_overlap[true_label][3] += len(true_labels[true_label])

    for prediction_label in predictions:
        if prediction_label not in dict_overlap:
            dict_overlap[prediction_label] = [0,0,0,0]
        dict_overlap[prediction_label][2] += len(predictions[prediction_label])

        matched_true = []
        matched_pred = []

        for token_predicted in predictions[prediction_label]:

            token_predicted_ori = token_predicted[:]

            token_predicted = token_predicted.strip(',\'()[]\.')
            if prediction_label == 'METHOD':
                token_predicted = token_predicted.replace('-', ' ').replace('(', ' ').replace(')', ' ').replace('+', ' ').replace("’", ' ')

            if prediction_label in true_labels:

                #token of actual
                counted = False
                for token_true in true_labels[prediction_label]:


                    token_true_ = [token_true]

                    if prediction_label in ['MATERIAL']:
                        alternate = alternate_labels(token_true)
                        token_true_ += alternate

                    matched = False

                    for true in token_true_:

                        # if prediction_label in ["MATERIAL", "STRUCTURE"]:
                        true = true.strip(',\'()[]\.')

                        if prediction_label == 'METHOD':
                            true = true.replace('-', ' ').replace('(', ' ').replace(')', ' ').replace('+', ' ').replace("’", ' ')
                            # token_predicted = token_predicted.replace('-', ' ').replace('(', ' ').replace(')', ' ').replace('+', ' ').replace("'", ' ')

                        # token_predicted = token_predicted.strip(',\'()[]')

                        # print(token_predicted, true)
                        if token_predicted.replace(' ','').lower() in true.replace(' ','').lower():
                            if not counted:
                                dict_overlap[prediction_label][0] += 1
                                counted = True
                            matched_true.append(token_true)
                            matched = True
                            # break

                        if true.replace(' ','').lower() in token_predicted.replace(' ','').lower():
                            if not counted:
                                dict_overlap[prediction_label][0] += 1
                                counted = True
                            matched_true.append(token_true)
                            matched = True
                            # break

                        if prediction_label in ['MATERIAL', 'STRUCTURE']:

                            token_true_list = [x for x in true.lower().split() if len(x)>=2]
                            token_predicted_list = [x for x in token_predicted.lower().split() if len(x)>=2]

                            # print(token_true_list, token_predicted_list)
                            if len(set(token_true_list).intersection(set(token_predicted_list))) >= 1:
                                if not counted:
                                    dict_overlap[prediction_label][0] += 1
                                    counted = True
                                matched_true.append(token_true)
                                matched = True
                                # break

                    if matched:
                        matched_pred.append(token_predicted_ori)

        matched_true = set(matched_true)
        matched_pred = set(matched_pred)

        # print(matched_pred)

        matched_true_dict[prediction_label] = matched_true
        matched_pred_dict[prediction_label] = matched_pred

        dict_overlap[prediction_label][1] = len(matched_true)


    for label in dict_overlap:
        print(label + ' - '+str(dict_overlap[label][0])+' ,'+str(dict_overlap[label][1])+', '+str(dict_overlap[label][2])+', '+str(dict_overlap[label][3]))

    return dict_overlap, matched_true_dict, matched_pred_dict

def print_results_to_file(file, results, matched_dict, show_unmatched, values_s, outputs_s):

    results_ = results

    fout = open(file, 'w')
    for label in results:
        # if label != 'STRUCTURE':
        #     continue
        #print(label, file=fout)
        #print('---------------', file=fout)
        for key in results[label]:

            if show_unmatched and label in matched_dict and key in matched_dict[label]:
                del results_[label][key]
                continue
            #print(key, file=fout)

        #print('\n', file=fout)

    results_print = {}
    for key in results_:
        results_print[key] = list(results_[key])

    fout.write(json.dumps(results_print))
    fout.close()

def predict(sentences: Union[str, List[str]], path, insts, filter_maethodparam, filter_material, filter_structure, show_unmatched):


    # write_results('results/'+path, insts)
    valid_sections_true = getinfo(path, 'true')
    valid_sections_pred = getinfo(path, 'pred')

    # print(valid_sections_true)
    # print(valid_sections_pred)

    predictions, label_section_p, values_p, values_s, outputs_s = create_dict_pred(insts, valid_sections_pred, filter_maethodparam, filter_material, filter_structure)
    true_labels, label_section_t = create_dict_true(insts, valid_sections_true, filter_maethodparam, filter_material)

    # print(predictions)

    try:
        assert(len(labels) == sum([len(true_labels[key]) for key in true_labels]))
    except:
        #print(labels)
        # print(true_labels)
        pass

    dict_overlap, matched_true_dict, matched_pred_dict = evaluate(predictions, true_labels)

    # print(outputs_s)

    print_results_to_file('results/'+''.join((''.join(path.split('/')[-1])).split('.')[:-1])+'.pred', predictions, matched_pred_dict, show_unmatched, values_s, outputs_s)
    print_results_to_file('results/'+''.join((''.join(path.split('/')[-1])).split('.')[:-1])+'.true', true_labels, matched_true_dict, show_unmatched, {}, {})

    return dict_overlap, predictions, true_labels

def create_semisupervised_data(predictions, path, dest_dir):
    fname = (path.split('/'))[-1]
    labels_list = [label for label in predictions]
    file = open(path,"r+")
    new_file = open(dest_dir + '/' + fname, 'w+')
    lines = file.readlines()
    i=0
    total_lines = len(lines)
    prev_line_empty = True
    while i<total_lines:
        line = lines[i].strip("\n")
        #print(i)
        if line == "":
            prev_line_empty = True
            new_file.write("\n")
        else:
            if prev_line_empty:
                #Skip this line
                prev_line_empty = False
                i+=1
                continue

            words = [x for x in line.split()]
            # if words[0]!="section":
            if words[1]=="O":
                words[1] = "B-MATERIAL"
            if words[1].startswith("I-")!=True:
                label = words[1][2:]
                flag = 0
                if label not in labels_list:
                    new_file.write(words[0]+" "+"O\n")
                    i +=1
                    continue
                
                for key in predictions[label]:
                    length = len([x for x in key.split()])
                    temp = ""
                    for j in range(i,i+length):
                        if j>=total_lines:
                            break
                        temp_line = lines[j].strip("\n")
                        if temp_line!="":
                            temp_words = [x for x in temp_line.split()]
                            temp = temp+" " +temp_words[0]
                    temp = temp[1:]
                    if temp==key:
                        flag = 1
                        for j in range(i,i+length):
                            temp_line = lines[j].strip("\n")
                            temp_words = [x for x in temp_line.split()]
                            if j-i==0:
                                new_file.write(temp_words[0]+ " B-"+ label+"\n" )
                            else:
                                new_file.write(temp_words[0]+ " I-"+ label+"\n" )
                        i = i+length-1
                        break
                if flag!=1:
                    new_file.write(words[0]+" "+"O\n")
            else:
                new_file.write(words[0]+" "+"O\n")
            # else:
            #     prev_line_empty = True
            #     new_file.write(line+"\n")
        # else:
        #     prev_line_empty = True
        #     new_file.write("\n")
        i+=1
    file.close()
    new_file.close()


def read_txt(file: str, number: int = -1):

    insts = []

    digit2zero = False
    insts = []
    sentences = []
    predictions = []

    sentence = ''
    sections = []
    
    prediction = []
    true_label = []

    with open(file, 'r', encoding='utf-8') as f:
        
        for line in f:
            line = line.strip()
            if line=='':
                if sentence.strip()!='':
                    sentences.append(' '.join(sentence.split(' ')[1:]))
                    sections.append(prediction[0])
                    predictions.append(prediction[1:])
                    inst = Instance(input=Sentence(words=sentence.split()[1:], heading=prediction[0]))
                    inst.output = true_label
                    inst.prediction = prediction[1:]
                    insts.append(inst)

                    # print(len(sentence.split()[1:]))
                    # print(len(label[1:]))
                    # print(len(output))
                    
                sentence = ''
                prediction = []
                true_label = []
            else:
                if digit2zero:
                    sentence += re.sub('\d', '0', line.split()[0])+' '
                else:
                    sentence += line.split()[0]+' '
                prediction.append(line.split()[1])
                if len(line.split())==3:
                    true_label.append(line.split()[2])
                
        if sentence.strip()!='':
            sentences.append(' '.join(sentence.split(' ')[1:]))
            sections.append(prediction[0])
            predictions.append(prediction[1:])
            inst = Instance(input=Sentence(words=sentence.split()[1:], heading=prediction[0]))
            inst.output = true_label
            inst.prediction = prediction[1:]
            insts.append(inst)
            # print(len(sentence.split()[1:]))
            # print(len(label[1:]))
            # print(len(output))

    return sentences, sections, predictions, insts


def getinfo(id, pred_or_true='true'):
    info = {}
    prev_method=""
    prev_section=""

    with open(id) as f:
        line = []
        for each in f:
            each = each.strip()
            if each == '':
                section = line[0]
                if section!=prev_section:
                    prev_section = section
                    prev_method = ""
                new_line = [section,id]
                input_word = ""
                met=0
                para=0
                prev_label="O"
                for word_label in line[1:]:
                    if pred_or_true == 'true':
                        word, _, label = word_label.split()
                    else:
                        word, label, _ = word_label.split()
                    key=0
                    if "B-METHOD" in label:
                        key=1
                        met=1
                        para=0
                        if len(input_word)!=0:
                            new_line.append(input_word+" "+prev_label)
                        input_word=word
                        prev_label=label
                    if "I-METHOD" in label and met==1:
                        key=1
                        input_word += " "+word
                    if "B-PARAMETER" in label:
                        key=1
                        para=1
                        met=0
                        if len(input_word)!=0:
                            new_line.append(input_word+" "+prev_label)
                        input_word=word
                        prev_label=label
                    if "I-PARAMETER" in label and para==1:
                        key=1
                        input_word+=" "+word
                    if key==0:
                        met=0
                        para=0
                        if len(input_word)!=0:
                            new_line.append(input_word+" "+prev_label)
                        new_line.append(word+" "+label)
                        input_word=""
                        prev_label="O"
                if len(input_word)!=0:
                    new_line.append(input_word+" "+prev_label)

                for word_label in new_line[2:]:
                    word_label_list = [x for x in word_label.split()]
                    label = word_label_list[-1]
                    word = ""
                    for i in word_label_list[:-1]:
                        word+=" "+i
                    info_list = []
                    if "METHOD" in label:
                        temp = (word,section)
                        if temp not in info.keys():
                            info[temp] = info_list 
                        else:
                            info_list = info[temp]
                        prev_method=word
                        prev_section=section
                    if "PARAMETER" in label:
                        if len(prev_method)!=0:
                            info_list = info[(prev_method,section)]
                            info_list.append(word)
                            info[(prev_method,section)] = info_list
                line = []
                continue
            line.append(each)

    new_info = {}
    for each in info:
        if len(info[each]) > 0:
            new_info[each] = info[each]

    # print(new_info)

    valid_sections = []
    for each in new_info:
        _,section = each
        section = section.split(' ')[1].strip()
        valid_sections.append(section)
    # print("\n")
    return valid_sections

def str2bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        return False


if __name__ == '__main__':

    nlp = en_core_sci_sm.load()

    paper_dir = '../../pdfs/data_18-01-2020/one/test'

    parser = argparse.ArgumentParser(description='Create test dataset.')
    parser.add_argument("-paperDir",dest='paper_dir',action='store',help="directory that contains the parsed pdf files")
    parser.add_argument("-filterMaterial",dest='filter_material',action='store', help="set true if material needs to be filtered")
    parser.add_argument("-filterStructure",dest='filter_structure',action='store', help="set true if structure needs to be filtered")
    parser.add_argument("-filterMethodParam",dest='filter_maethodparam',action='store', help="set true if method param needs to be filtered")
    parser.add_argument("-printOnlyUnmatched",dest='show_unmatched',action='store', help="set true if only unmatched entries are to be printed to predictions")
    parser.add_argument("-MaterialPred",dest='material_predictor',action='store', help="set true if it is a material predictor")
    parser.add_argument("-semisupervised_dest_dir", dest='semisupervised_dest_dir', action='store', default=None, help="directory to store semisupervised files")
    args = parser.parse_args()

    paper_dir = args.paper_dir
    filter_material = str2bool(args.filter_material)
    filter_structure = str2bool(args.filter_structure)
    filter_maethodparam = str2bool(args.filter_maethodparam)
    show_unmatched = str2bool(args.show_unmatched)
    mat_pred = str2bool(args.material_predictor)
    semisupervised_dest_dir = args.semisupervised_dest_dir
    metrics_overlap = {}
    for subdir, dirs, files in os.walk(paper_dir):
        for file in tqdm(files, desc="Files"):
            paper = os.path.join(subdir, file)
            if not paper.endswith('.prediction'):
                continue
            # if paper != '../../pdfs/all_mimicking_model_part2_updated/29-01-2020-part1-1409.4135v1.Computing_total_energies_in_complex_materials_using_charge_self_consistent_DFT_DMFT.pdf.prediction':
            #     continue
            print(paper)

            sentences, sections, _, insts = read_txt(file=paper)
            dict_overlap, predictions,_ = predict(sentences, paper, insts, filter_maethodparam, filter_material, filter_structure, show_unmatched)
            if semisupervised_dest_dir:
                create_semisupervised_data(predictions, paper, semisupervised_dest_dir)


            for label in dict_overlap:
                if label not in metrics_overlap:
                    metrics_overlap[label] = [0,0,0,0]
                metrics_overlap[label][0] += dict_overlap[label][0]
                metrics_overlap[label][1] += dict_overlap[label][1]
                metrics_overlap[label][2] += dict_overlap[label][2]
                metrics_overlap[label][3] += dict_overlap[label][3]

            # break

    print(metrics_overlap)
    # for label in metrics_overlap:
    #     p_overlap, total_predict, total_entity = metrics_overlap[label][0], metrics_overlap[label][1], metrics_overlap[label][2]
    #     precision_overlap = min([100, p_overlap * 1.0 / total_predict * 100]) if total_predict != 0 else 0
    #     recall_overlap = min([100, p_overlap * 1.0 / total_entity * 100]) if total_entity != 0 else 0
    #     fscore_overlap = min([100, 2.0 * precision_overlap * recall_overlap / (precision_overlap + recall_overlap)]) if precision_overlap != 0 or recall_overlap != 0 else 0
    #     print("[%s set - Exact] Precision: %.2f, Recall: %.2f, F1: %.2f" % (label, precision_overlap, recall_overlap, fscore_overlap), flush=True)

    for label in metrics_overlap:
        prec_num, recall_num, total_predict, total_entity = metrics_overlap[label][0], metrics_overlap[label][1], metrics_overlap[label][2], metrics_overlap[label][3]
        precision_overlap = prec_num * 1.0 / total_predict * 100 if total_predict > 0 else 0
        recall_overlap = recall_num * 1.0 / total_entity * 100 if total_entity > 0 else 0
        fscore_overlap = 2.0 * precision_overlap * recall_overlap / (precision_overlap + recall_overlap) if (precision_overlap + recall_overlap) !=0 else 0
        print("[%s set - Overlap] Precision: %.2f, Recall: %.2f, F1: %.2f" % (label, precision_overlap, recall_overlap, fscore_overlap), flush=True)
